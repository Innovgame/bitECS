{
  "version": 3,
  "sources": ["../../src/serialization/index.ts", "../../src/serialization/SoASerializer.ts", "../../src/serialization/AoSSerializer.ts", "../../src/serialization/SnapshotSerializer.ts", "../../src/serialization/ObserverSerializer.ts"],
  "sourcesContent": ["\nexport {\n    createSoASerializer,\n    createSoADeserializer,\n    u8, i8, u16, i16, u32, i32, f32, f64, str, array, ref,\n    $i8, $u16, $i16, $u32, $i32, $f32, $f64, $u8, $str, $ref,\n    type PrimitiveBrand\n} from './SoASerializer'\n\nexport {\n    createAoSSerializer,\n    createAoSDeserializer,\n    type AoSSerializerOptions,\n    type AoSDeserializerOptions\n} from './AoSSerializer'\n\nexport {\n    createSnapshotSerializer,\n    createSnapshotDeserializer,\n} from './SnapshotSerializer'\n\nexport {\n    createObserverSerializer,\n    createObserverDeserializer\n} from './ObserverSerializer';\n\nexport type {\n    ObserverSerializerOptions,\n    ObserverDeserializerOptions\n} from './ObserverSerializer'", "\n/**\n * Symbols representing different data types for serialization.\n */\nexport const $u8 = Symbol.for('bitecs-u8'), $i8 = Symbol.for('bitecs-i8'), $u16 = Symbol.for('bitecs-u16'), $i16 = Symbol.for('bitecs-i16'),\n    $u32 = Symbol.for('bitecs-u32'), $i32 = Symbol.for('bitecs-i32'), $f32 = Symbol.for('bitecs-f32'), $f64 = Symbol.for('bitecs-f64'),\n    $ref = Symbol.for('bitecs-ref'),\n    $str = Symbol.for('bitecs-str'),\n    $arr = Symbol.for('bitecs-arr')\n\n/**\n * Union type of all possible TypedArray types.\n */\nexport type TypedArray = \n    | Int8Array\n    | Uint8Array\n    | Int16Array\n    | Uint16Array\n    | Int32Array\n    | Uint32Array\n    | Float32Array\n    | Float64Array\n\n/**\n * Union type of all possible type symbols.\n */\nexport type TypeSymbol = typeof $u8 | typeof $i8 | typeof $u16 | typeof $i16 | typeof $u32 | typeof $i32 | typeof $f32 | typeof $f64 | typeof $str | typeof $ref\n\n/**\n * Type representing a primitive brand, which is either a number array with a symbol property or a TypedArray.\n */\nexport type PrimitiveBrand = ((number[] | string[]) & { [key: symbol]: true }) | TypedArray\n\n/**\n * Type representing a component reference, which is a record mapping string keys to either\n * a PrimitiveBrand (number array with type symbol), TypedArray, or ArrayType values.\n * Used to define the structure of components that can be serialized.\n */\nexport type ComponentRef = Record<string, any>\n\nexport type ArrayType<T> = T[] & { [$arr]: TypeSymbol | TypeFunction | ArrayType<any> }\n\n/**\n * Creates a function that tags an array with a type symbol for serialization.\n * @param {TypeSymbol} symbol - The type symbol to tag the array with.\n * @returns {Function} A function that tags an array with the given type symbol.\n */\nconst typeTagForSerialization = <T extends any[] = number[]>(symbol: TypeSymbol) => (a: T = [] as T): T & { [key: symbol]: true } =>\n    Object.defineProperty(a, symbol, { value: true, enumerable: false, writable: false, configurable: false }) as T & { [key: symbol]: true }\n\n/**\n * Functions to create arrays tagged with specific type symbols.\n */\nexport const u8 = (a: number[] = []): number[] => typeTagForSerialization($u8)(a) as number[],\n            i8 = (a: number[] = []): number[] => typeTagForSerialization($i8)(a) as number[],\n            u16 = (a: number[] = []): number[] => typeTagForSerialization($u16)(a) as number[],\n            i16 = (a: number[] = []): number[] => typeTagForSerialization($i16)(a) as number[],\n            u32 = (a: number[] = []): number[] => typeTagForSerialization($u32)(a) as number[],\n            i32 = (a: number[] = []): number[] => typeTagForSerialization($i32)(a) as number[],\n            f32 = (a: number[] = []): number[] => typeTagForSerialization($f32)(a) as number[],\n            f64 = (a: number[] = []): number[] => typeTagForSerialization($f64)(a) as number[],\n            ref = (a: number[] = []): number[] => typeTagForSerialization($ref)(a) as number[],\n            str = (a: string[] = []): string[] => typeTagForSerialization<string[]>($str)(a) as string[]\n\n/**\n * Type representing a type function.\n */\ntype TypeFunction = typeof u8 | typeof i8 | typeof u16 | typeof i16 | typeof u32 | typeof i32 | typeof f32 | typeof f64 | typeof str | typeof ref\n\n/**\n * Mapping from type functions to their corresponding symbols.\n */\nconst functionToSymbolMap = new Map<TypeFunction, TypeSymbol>([\n    [u8, $u8], [i8, $i8], [u16, $u16], [i16, $i16],\n    [u32, $u32], [i32, $i32], [f32, $f32], [f64, $f64],\n    [ref, $ref],\n    [str, $str]\n])\n\n/**\n * Object containing setter functions for each data type.\n */\nexport const typeSetters: Record<TypeSymbol, (view: DataView, offset: number, value: any) => number> = {\n    [$u8]: (view: DataView, offset: number, value: number) => { view.setUint8(offset, value); return 1; },\n    [$i8]: (view: DataView, offset: number, value: number) => { view.setInt8(offset, value); return 1; },\n    [$u16]: (view: DataView, offset: number, value: number) => { view.setUint16(offset, value); return 2; },\n    [$i16]: (view: DataView, offset: number, value: number) => { view.setInt16(offset, value); return 2; },\n    [$u32]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$i32]: (view: DataView, offset: number, value: number) => { view.setInt32(offset, value); return 4; },\n    [$f32]: (view: DataView, offset: number, value: number) => { view.setFloat32(offset, value); return 4; },\n    [$f64]: (view: DataView, offset: number, value: number) => { view.setFloat64(offset, value); return 8; },\n    [$ref]: (view: DataView, offset: number, value: number) => { view.setUint32(offset, value); return 4; },\n    [$str]: (view: DataView, offset: number, value: string) => {\n        const enc = textEncoder\n        const bytes = enc.encode(value)\n        let written = 0\n        written += typeSetters[$u32](view, offset + written, bytes.length)\n        new Uint8Array(view.buffer, view.byteOffset + offset + written, bytes.length).set(bytes)\n        written += bytes.length\n        return written\n    }\n} as Record<TypeSymbol, (view: DataView, offset: number, value: any) => number>\n\n/**\n * Object containing getter functions for each data type.\n */\nexport const typeGetters: Record<TypeSymbol, (view: DataView, offset: number) => { value: any, size: number }> = {\n    [$u8]: (view: DataView, offset: number) => ({ value: view.getUint8(offset), size: 1 }),\n    [$i8]: (view: DataView, offset: number) => ({ value: view.getInt8(offset), size: 1 }),\n    [$u16]: (view: DataView, offset: number) => ({ value: view.getUint16(offset), size: 2 }),\n    [$i16]: (view: DataView, offset: number) => ({ value: view.getInt16(offset), size: 2 }),\n    [$u32]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$i32]: (view: DataView, offset: number) => ({ value: view.getInt32(offset), size: 4 }),\n    [$f32]: (view: DataView, offset: number) => ({ value: view.getFloat32(offset), size: 4 }),\n    [$f64]: (view: DataView, offset: number) => ({ value: view.getFloat64(offset), size: 8 }),\n    [$ref]: (view: DataView, offset: number) => ({ value: view.getUint32(offset), size: 4 }),\n    [$str]: (view: DataView, offset: number) => {\n        const { value: len, size: lenSize } = typeGetters[$u32](view, offset)\n        const bytes = new Uint8Array(view.buffer, view.byteOffset + offset + lenSize, len)\n        const dec = textDecoder\n        const strValue = dec.decode(bytes)\n        return { value: strValue, size: lenSize + len }\n    }\n} as Record<TypeSymbol, (view: DataView, offset: number) => { value: any, size: number }>\n\n/**\n * Resolves a type (symbol, function, or array type) to its corresponding symbol.\n */\nfunction resolveTypeToSymbol(type: TypeSymbol | TypeFunction | ArrayType<any>): TypeSymbol {\n    if (typeof type === 'symbol') {\n        return type\n    }\n    if (typeof type === 'function') {\n        const symbol = functionToSymbolMap.get(type)\n        if (symbol) return symbol\n        throw new Error(`Unknown type function: ${type}`)\n    }\n    if (isArrayType(type)) {\n        return resolveTypeToSymbol(type[$arr])\n    }\n    // Default fallback\n    return $f32\n}\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport function array(type: typeof $str | typeof str): ArrayType<string[]>\nexport function array(type?: TypeSymbol | TypeFunction): ArrayType<number[]>\nexport function array<T>(type: ArrayType<T>): ArrayType<T[]>\nexport function array(type: TypeSymbol | TypeFunction | ArrayType<any> = f64): ArrayType<any> {\n\tconst arr = [] as any[]\n\tObject.defineProperty(arr, $arr, { value: type, enumerable: false, writable: false, configurable: false })\n\treturn arr as ArrayType<any>\n}\n\n/**\n * Checks if a value is a TypedArray, branded array, or ArrayType\n */\nfunction isTypedArrayOrBranded(arr: any): arr is PrimitiveBrand | TypedArray | ArrayType<any> {\n    return arr && (\n        ArrayBuffer.isView(arr) || \n        (Array.isArray(arr) && typeof arr === 'object')\n    )\n}\n\n/**\n * Gets the type symbol for an array\n */\nexport function getTypeForArray(arr: PrimitiveBrand | TypedArray | ArrayType<any>): TypeSymbol {\n    // Check for ArrayType first\n    if (isArrayType(arr)) {\n        return resolveTypeToSymbol(arr[$arr])\n    }\n    // Check for branded arrays\n    for (const symbol of [$u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64, $str, $ref] as TypeSymbol[]) {\n        if (symbol in arr) return symbol\n    }\n    // Then check TypedArrays\n    if (arr instanceof Int8Array) return $i8\n    if (arr instanceof Uint8Array) return $u8\n    if (arr instanceof Int16Array) return $i16\n    if (arr instanceof Uint16Array) return $u16\n    if (arr instanceof Int32Array) return $i32\n    if (arr instanceof Uint32Array) return $u32\n    if (arr instanceof Float32Array) return $f32\n    return $f64\n}\n\n/**\n * Checks if a value is an array type\n */\nexport function isArrayType(value: any): value is ArrayType<any> {\n    return Array.isArray(value) && $arr in value\n}\n\n/**\n * Gets the element type information for an array type\n */\nexport function getArrayElementType(arrayType: ArrayType<any>): TypeSymbol | TypeFunction | ArrayType<any> {\n    return arrayType[$arr]\n}\n\n/**\n * Serializes an array value to a DataView\n */\nexport function serializeArrayValue(\n    elementType: ArrayType<any> | TypeSymbol | TypeFunction,\n    value: any[],\n    view: DataView,\n    offset: number\n): number {\n    let bytesWritten = 0\n\n    const isArrayDefined = Array.isArray(value) ? 1 : 0\n    bytesWritten += typeSetters[$u8](view, offset, isArrayDefined)\n\n    if (!isArrayDefined) {\n        return bytesWritten\n    }\n\n    bytesWritten += typeSetters[$u32](view, offset + bytesWritten, value.length)\n\n    // Write each element\n    for (let i = 0; i < value.length; i++) {\n        const element = value[i]\n        if (isArrayType(elementType)) {\n            bytesWritten += serializeArrayValue(getArrayElementType(elementType), element, view, offset + bytesWritten)\n        } else {\n            // Primitive type - resolve to symbol\n            const symbol = resolveTypeToSymbol(elementType)\n            bytesWritten += typeSetters[symbol](view, offset + bytesWritten, element)\n        }\n    }\n\n    return bytesWritten\n}\n\n\nexport function deserializeArrayValue(\n    elementType: ArrayType<any> | TypeSymbol | TypeFunction,\n    view: DataView,\n    offset: number,\n    entityIdMapping?: Map<number, number>\n) {\n    let bytesRead = 0\n\n    const isArrayResult = typeGetters[$u8](view, offset + bytesRead)\n    bytesRead += isArrayResult.size\n    if (!isArrayResult.value) {\n        return { size: bytesRead }\n    }\n\n    const arrayLengthResult = typeGetters[$u32](view, offset + bytesRead)\n    bytesRead += arrayLengthResult.size;\n\n    const arr = new Array(arrayLengthResult.value) as any;\n    for (let i = 0; i < arr.length; i++) {\n        if (isArrayType(elementType)) {\n            const { value, size } = deserializeArrayValue(getArrayElementType(elementType), view, offset + bytesRead, entityIdMapping)\n            bytesRead += size\n            if (Array.isArray(value)) {\n                arr[i] = value\n            }\n        } else {\n            // Primitive type - resolve to symbol\n            const symbol = resolveTypeToSymbol(elementType)\n            const { value, size } = typeGetters[symbol](view, offset + bytesRead)\n            bytesRead += size\n            if (symbol === $ref) {\n                const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n                arr[i] = mapped\n            } else {\n                arr[i] = value\n            }\n        }\n    }\n\n    return { value: arr, size: bytesRead }\n}\n\n/**\n * Checks if an array type is a float type\n */\nconst isFloatType = (array: any) => {\n    const arrayType = getTypeForArray(array)\n    return arrayType === $f32 || arrayType === $f64\n}\n\n/**\n * Gets epsilon value for an array type (0 for non-floats)\n */\nconst getEpsilonForType = (array: any, epsilon: number) => \n    isFloatType(array) ? epsilon : 0\n\n/**\n * Gets or creates a shadow array for change detection\n */\nconst getShadow = (shadowMap: Map<any, any>, array: any) => {\n    let shadow = shadowMap.get(array)\n    if (!shadow) {\n        // Create shadow array with proper initialization\n        if (ArrayBuffer.isView(array)) {\n            // TypedArray\n            shadow = new (array.constructor as any)((array as any).length)\n        } else {\n            // Regular array (like f32([]) arrays) - initialize with zeros\n            shadow = new Array(array.length).fill(0)\n        }\n        shadowMap.set(array, shadow)\n    }\n    return shadow\n}\n\n/**\n * Checks if a value has changed and updates the shadow\n */\nconst hasChanged = (shadowMap: Map<any, any>, array: any, index: number, epsilon = 0.0001) => {\n    const shadow = getShadow(shadowMap, array)\n    const currentValue = array[index]\n    const actualEpsilon = getEpsilonForType(array, epsilon)\n    \n    const changed = actualEpsilon > 0\n        ? Math.abs(shadow[index] - currentValue) > actualEpsilon\n        : shadow[index] !== currentValue\n    \n    shadow[index] = currentValue\n    return changed\n}\n\n/**\n * Creates a serializer function for a component.\n * @param {ComponentRef} component - The component to create a serializer for.\n * @param {boolean} diff - Whether to use diff mode (only serialize changed values).\n * @param {Map} shadowMap - Map to store shadow copies for diff mode.\n * @param {number} epsilon - Epsilon for float comparison in diff mode.\n * @returns {Function} A function that serializes the component.\n */\nexport const createComponentSerializer = (component: ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>, diff = false, shadowMap?: Map<any, any>, epsilon = 0.0001) => {\n    // Handle direct array case\n    if (isTypedArrayOrBranded(component)) {\n        const type = getTypeForArray(component)\n        const setter = typeSetters[type]\n        return (view: DataView, offset: number, index: number, componentId: number) => {\n            if (diff && shadowMap) {\n                if (!hasChanged(shadowMap, component, index, epsilon)) return 0 // No change\n                \n                let bytesWritten = 0\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, componentId) // cid\n                bytesWritten += setter(view, offset + bytesWritten, component[index])\n                return bytesWritten\n            } else {\n                let bytesWritten = 0\n                bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n                bytesWritten += setter(view, offset + bytesWritten, component[index])\n                return bytesWritten\n            }\n        }\n    }\n\n    // Handle component case\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        if (!isTypedArrayOrBranded(arr)) {\n            throw new Error(`Invalid array type for property ${prop}`)\n        }\n        return getTypeForArray(arr)\n    })\n    const setters = types.map(type => typeSetters[type as keyof typeof typeSetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, index: number, componentId: number) => {\n        if (diff && shadowMap) {\n            let changeMask = 0\n            // First pass: check what changed and build mask\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                \n                if (hasChanged(shadowMap, componentProperty, index, epsilon)) {\n                    changeMask |= 1 << i\n                }\n            }\n            \n            if (changeMask === 0) return 0 // No changes for this component\n            \n            let bytesWritten = 0\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, componentId) // cid\n            \n            // Write mask\n            const maskSetter = props.length <= 8 ? typeSetters[$u8] : props.length <= 16 ? typeSetters[$u16] : typeSetters[$u32]\n            bytesWritten += maskSetter(view, offset + bytesWritten, changeMask)\n            \n            // Write only changed values (shadows already updated by hasChanged)\n            for (let i = 0; i < props.length; i++) {\n                if (changeMask & (1 << i)) {\n                    const componentProperty = component[props[i]]\n                    \n                    if (isArrayType(componentProperty)) {\n                        bytesWritten += serializeArrayValue(getArrayElementType(componentProperty), componentProperty[index], view, offset + bytesWritten)\n                    } else {\n                        bytesWritten += setters[i](view, offset + bytesWritten, componentProperty[index])\n                    }\n                }\n            }\n            return bytesWritten\n        } else {\n            let bytesWritten = 0\n            bytesWritten += typeSetters[$u32](view, offset + bytesWritten, index) // eid\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                if (isArrayType(componentProperty)) {\n                    bytesWritten += serializeArrayValue(getArrayElementType(componentProperty), componentProperty[index], view, offset + bytesWritten)\n                } else {\n                    bytesWritten += setters[i](view, offset + bytesWritten, componentProperty[index])\n                }\n            }\n            return bytesWritten\n        }\n    }\n}\n\n/**\n * Creates a deserializer function for a component.\n * @param {ComponentRef} component - The component to create a deserializer for.\n * @param {boolean} diff - Whether to expect diff mode data with change masks.\n * @returns {Function} A function that deserializes the component.\n */\nexport const createComponentDeserializer = (component: ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>, diff = false) => {\n    // Handle direct array case\n    if (isTypedArrayOrBranded(component)) {\n        const type = getTypeForArray(component)\n        const getter = typeGetters[type]\n        return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n            let bytesRead = 0\n            const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset)\n            bytesRead += indexSize\n            const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n            \n            if (diff) {\n                // Skip cid (component ID)\n                const { size: cidSize } = typeGetters[$u32](view, offset + bytesRead)\n                bytesRead += cidSize\n            }\n            \n            const { value, size } = getter(view, offset + bytesRead)\n            if (type === $ref) {\n                const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n                ;(component as any)[index] = mapped\n            } else {\n                ;(component as any)[index] = value\n            }\n            return bytesRead + size\n        }\n    }\n\n    // Handle component case\n    const props = Object.keys(component)\n    const types = props.map(prop => {\n        const arr = component[prop]\n        if (!isTypedArrayOrBranded(arr)) {\n            throw new Error(`Invalid array type for property ${prop}`)\n        }\n        return getTypeForArray(arr)\n    })\n    const getters = types.map(type => typeGetters[type as keyof typeof typeGetters] || (() => { throw new Error(`Unsupported or unannotated type`); }))\n    return (view: DataView, offset: number, entityIdMapping?: Map<number, number>) => {\n        let bytesRead = 0\n\n        const { value: originalIndex, size: indexSize } = typeGetters[$u32](view, offset + bytesRead)\n        bytesRead += indexSize\n        \n        const index = entityIdMapping ? entityIdMapping.get(originalIndex) ?? originalIndex : originalIndex\n        \n        if (diff) {\n            // Skip cid (component ID)\n            const { size: cidSize } = typeGetters[$u32](view, offset + bytesRead)\n            bytesRead += cidSize\n            \n            const maskGetter = props.length <= 8 ? typeGetters[$u8] : props.length <= 16 ? typeGetters[$u16] : typeGetters[$u32]\n            const { value: changeMask, size: maskSize } = maskGetter(view, offset + bytesRead)\n            bytesRead += maskSize\n            \n            for (let i = 0; i < props.length; i++) {\n                if (changeMask & (1 << i)) {\n                    const componentProperty = component[props[i]]\n                    if (isArrayType(componentProperty)) {\n                        const { value, size } = deserializeArrayValue(getArrayElementType(componentProperty), view, offset + bytesRead, entityIdMapping)\n                        if (Array.isArray(value)){\n                            componentProperty[index] = value\n                        }\n                        bytesRead += size\n                    } else {\n                        const { value, size } = getters[i](view, offset + bytesRead)\n                        if (types[i] === $ref) {\n                            const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n                            component[props[i]][index] = mapped\n                        } else {\n                            component[props[i]][index] = value\n                        }\n                        bytesRead += size\n                    }\n                }\n            }\n        } else {\n            for (let i = 0; i < props.length; i++) {\n                const componentProperty = component[props[i]]\n                if (isArrayType(componentProperty)) {\n                    const { value, size } = deserializeArrayValue(getArrayElementType(componentProperty), view, offset + bytesRead, entityIdMapping)\n                    if (Array.isArray(value)){\n                        componentProperty[index] = value\n                    }\n                    bytesRead += size\n                } else {\n                    const { value, size } = getters[i](view, offset + bytesRead)\n                    if (types[i] === $ref) {\n                        const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n                        component[props[i]][index] = mapped\n                    } else {\n                        component[props[i]][index] = value\n                    }\n                    bytesRead += size\n                }\n            }\n        }\n        return bytesRead\n    }\n}\n\n/**\n * Options for SoA serializer\n */\nexport type SoASerializerOptions = {\n    diff?: boolean\n    buffer?: ArrayBuffer\n    epsilon?: number\n}\n\n/**\n * Creates a serializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to serialize.\n * @param {SoASerializerOptions} [options] - Serializer options.\n * @returns {Function} A function that serializes the SoA data.\n */\nexport const createSoASerializer = (components: (ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>)[], options: SoASerializerOptions = {}) => {\n    const { \n        diff = false, \n        buffer = new ArrayBuffer(1024 * 1024 * 100), \n        epsilon = 0.0001 \n    } = options\n    const view = new DataView(buffer)\n    const shadowMap = diff ? new Map() : undefined\n    const componentSerializers = components.map(component => createComponentSerializer(component, diff, shadowMap, epsilon))\n    return (indices: number[] | readonly number[]): ArrayBuffer => {\n        let offset = 0\n        for (let i = 0; i < indices.length; i++) {\n            const index = indices[i]\n            for (let j = 0; j < componentSerializers.length; j++) {\n                offset += componentSerializers[j](view, offset, index, j) // Pass component ID\n            }\n        }\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Options for SoA deserializer\n */\nexport type SoADeserializerOptions = {\n    diff?: boolean\n}\n\n/**\n * Creates a deserializer function for Structure of Arrays (SoA) data.\n * @param {ComponentRef[]} components - The components to deserialize.\n * @param {SoADeserializerOptions} [options] - Deserializer options.\n * @returns {Function} A function that deserializes the SoA data.\n */\nexport const createSoADeserializer = (components: (ComponentRef | PrimitiveBrand | TypedArray | ArrayType<any>)[], options: SoADeserializerOptions = {}) => {\n    const { diff = false } = options\n    const componentDeserializers = components.map(component => createComponentDeserializer(component, diff))\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n        while (offset < packet.byteLength) {\n            if (diff) {\n                // Read eid, cid\n                const { value: originalEid, size: eidSize } = typeGetters[$u32](view, offset)\n                const { value: componentId, size: cidSize } = typeGetters[$u32](view, offset + eidSize)\n                \n                // Call component deserializer starting from eid position\n                offset += componentDeserializers[componentId](view, offset, entityIdMapping)\n            } else {\n                for (let i = 0; i < componentDeserializers.length; i++) {\n                    offset += componentDeserializers[i](view, offset, entityIdMapping)\n                }\n            }\n        }\n    }\n}\n", "import { \n    $u8, $i8, $u16, $i16, $u32, $i32, $f32, $f64, $arr, $ref,\n    TypedArray, TypeSymbol, PrimitiveBrand, ArrayType,\n    typeSetters, typeGetters, getTypeForArray, isArrayType, getArrayElementType,\n    serializeArrayValue, deserializeArrayValue\n} from './SoASerializer'\n\n// Internal helper type for readability only\ntype AnyAoSComponent =\n    | PrimitiveBrand\n    | TypedArray\n    | ArrayType<any>\n    | Record<string, any>\n\n/**\n * Checks if an array type is a float type\n */\nconst isFloatType = (array: any) => {\n    const arrayType = getTypeForArray(array)\n    return arrayType === $f32 || arrayType === $f64\n}\n\n/**\n * Gets epsilon value for an array type (0 for non-floats)\n */\nconst getEpsilonForType = (array: any, epsilon: number) => \n    isFloatType(array) ? epsilon : 0\n\n/**\n * Gets or creates a shadow component array for change detection\n */\nconst getShadowComponent = (shadowMap: Map<any, any>, component: AnyAoSComponent) => {\n    let shadow = shadowMap.get(component)\n    if (!shadow) {\n        shadow = []\n        shadowMap.set(component, shadow)\n    }\n    return shadow\n}\n\n/**\n * Checks if a component value has changed for a specific entity\n */\nconst hasComponentChanged = (shadowMap: Map<any, any>, component: AnyAoSComponent, entityId: number, epsilon: number) => {\n    const shadow = getShadowComponent(shadowMap, component)\n    const currentValue = component[entityId]\n    const shadowValue = shadow[entityId]\n    \n    if (currentValue === undefined) return false\n    if (shadowValue === undefined) return true\n    \n    if (typeof currentValue === 'object' && currentValue !== null) {\n        // Object component - check each property\n        const componentDef = component as any // Has property definitions\n        for (const prop in currentValue) {\n            if (componentDef[prop]) {\n                const propEpsilon = getEpsilonForType(componentDef[prop], epsilon)\n                const changed = propEpsilon > 0\n                    ? Math.abs(shadowValue[prop] - currentValue[prop]) > propEpsilon\n                    : shadowValue[prop] !== currentValue[prop]\n                if (changed) return true\n            }\n        }\n        return false\n    } else {\n        // Direct value component\n        const valueEpsilon = getEpsilonForType(component, epsilon)\n        return valueEpsilon > 0\n            ? Math.abs(shadowValue - currentValue) > valueEpsilon\n            : shadowValue !== currentValue\n    }\n}\n\n/**\n * Updates shadow with current value\n */\nconst updateShadow = (shadowMap: Map<any, any>, component: AnyAoSComponent, entityId: number) => {\n    const shadow = getShadowComponent(shadowMap, component)\n    const currentValue = component[entityId]\n    \n    if (typeof currentValue === 'object' && currentValue !== null) {\n        // Deep copy object\n        shadow[entityId] = { ...currentValue }\n    } else {\n        // Direct value\n        shadow[entityId] = currentValue\n    }\n}\n\n/**\n * Creates a serializer for a single AoS component\n */\nconst createAoSComponentSerializer = (component: AnyAoSComponent, diff: boolean, shadowMap?: Map<any, any>, epsilon = 0.0001) => {\n    // Determine if this is an object component by checking if it has property definitions\n    const isObjectComponent = typeof component === 'object' && \n        Object.keys(component).some(key => isNaN(parseInt(key)) && typeof component[key] === 'object')\n    \n    if (isObjectComponent) {\n        // Object component like { x: f32(), y: f32() }\n        const props = Object.keys(component).filter(key => isNaN(parseInt(key)))\n        const types = props.map(prop => getTypeForArray(component[prop]))\n        const setters = types.map(type => typeSetters[type])\n        \n        return (view: DataView, offset: number, entityId: number) => {\n            const value = component[entityId]\n            if (value === undefined) return 0\n            \n            if (diff && shadowMap) {\n                if (!hasComponentChanged(shadowMap, component, entityId, epsilon)) {\n                    return 0\n                }\n                updateShadow(shadowMap, component, entityId)\n            }\n            \n            let bytesWritten = 0\n            \n            // Serialize all properties\n            for (let i = 0; i < props.length; i++) {\n                const prop = component[props[i]]\n                const propValue = value[props[i]]\n                \n                if (isArrayType(prop)) {\n                    bytesWritten += serializeArrayValue(getArrayElementType(prop), propValue, view, offset + bytesWritten)\n                } else {\n                    bytesWritten += setters[i](view, offset + bytesWritten, propValue)\n                }\n            }\n            \n            return bytesWritten\n        }\n    } else {\n        // Direct value component\n        const type = getTypeForArray(component as PrimitiveBrand | TypedArray | ArrayType<any>)\n        const setter = typeSetters[type]\n        \n        return (view: DataView, offset: number, entityId: number) => {\n            const value = (component as any)[entityId]\n            if (value === undefined) return 0\n            \n            if (diff && shadowMap) {\n                if (!hasComponentChanged(shadowMap, component as any, entityId, epsilon)) {\n                    return 0\n                }\n                updateShadow(shadowMap, component as any, entityId)\n            }\n            \n            return setter(view, offset, value)\n        }\n    }\n}\n\n/**\n * Creates a deserializer for a single AoS component\n */\nconst createAoSComponentDeserializer = (component: AnyAoSComponent) => {\n    // Determine if this is an object component\n    const isObjectComponent = typeof component === 'object' && \n        Object.keys(component).some(key => isNaN(parseInt(key)) && typeof component[key] === 'object')\n    \n    if (isObjectComponent) {\n        // Object component\n        const props = Object.keys(component).filter(key => isNaN(parseInt(key)))\n        const types = props.map(prop => getTypeForArray(component[prop]))\n        const getters = types.map(type => typeGetters[type])\n        \n        return (view: DataView, offset: number, entityId: number, entityIdMapping?: Map<number, number>) => {\n            let bytesRead = 0\n            const value: any = {}\n            \n            // Deserialize all properties\n            for (let i = 0; i < props.length; i++) {\n                const prop = component[props[i]]\n                \n                if (isArrayType(prop)) {\n                    const { value: propValue, size } = deserializeArrayValue(getArrayElementType(prop), view, offset + bytesRead, entityIdMapping)\n                    if (Array.isArray(propValue)) {\n                        value[props[i]] = propValue\n                    }\n                    bytesRead += size\n                } else {\n                    const { value: propValue, size } = getters[i](view, offset + bytesRead)\n                    if (types[i] === $ref) {\n                        const mapped = entityIdMapping ? entityIdMapping.get(propValue) ?? propValue : propValue\n                        value[props[i]] = mapped\n                    } else {\n                        value[props[i]] = propValue\n                    }\n                    bytesRead += size\n                }\n            }\n            \n            component[entityId] = value\n            return bytesRead\n        }\n    } else {\n        // Direct value component\n        const type = getTypeForArray(component as PrimitiveBrand | TypedArray | ArrayType<any>)\n        const getter = typeGetters[type]\n        \n        return (view: DataView, offset: number, entityId: number, entityIdMapping?: Map<number, number>) => {\n            const { value, size } = getter(view, offset)\n            if (type === $ref) {\n                const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n                ;(component as any)[entityId] = mapped\n            } else {\n                ;(component as any)[entityId] = value\n            }\n            return size\n        }\n    }\n}\n\n/**\n * Options for AoS serializer\n */\nexport type AoSSerializerOptions = {\n    diff?: boolean\n    buffer?: ArrayBuffer\n    epsilon?: number\n}\n\n/**\n * Creates a serializer function for Array of Structures (AoS) components.\n * @param {AoSComponentRef[]} components - The AoS components to serialize.\n * @param {AoSSerializerOptions} [options] - Serializer options.\n * @returns {Function} A function that serializes the AoS data.\n */\nexport const createAoSSerializer = (components: AnyAoSComponent[], options: AoSSerializerOptions = {}) => {\n    const { \n        diff = false, \n        buffer = new ArrayBuffer(1024 * 1024 * 100), \n        epsilon = 0.0001 \n    } = options\n\n    const view = new DataView(buffer)\n    const shadowMap = diff ? new Map<any, any>() : undefined\n    const componentSerializers = components.map(component => \n        createAoSComponentSerializer(component, diff, shadowMap, epsilon)\n    )\n\n    return (entityIds: number[] | readonly number[]): ArrayBuffer => {\n        let offset = 0\n        \n        for (let i = 0; i < entityIds.length; i++) {\n            const entityId = entityIds[i]\n            \n            if (diff) {\n                // Check if any component has changes for this entity\n                let entityHasChanges = false\n                for (let j = 0; j < components.length; j++) {\n                    if (shadowMap && hasComponentChanged(shadowMap, components[j], entityId, epsilon)) {\n                        entityHasChanges = true\n                        break\n                    }\n                }\n                \n                if (!entityHasChanges) continue\n                \n                // Write entity ID\n                offset += typeSetters[$u32](view, offset, entityId)\n                \n                // Write changed components and build mask\n                const maskOffset = offset\n                const maskSetter = components.length <= 8 ? typeSetters[$u8] : components.length <= 16 ? typeSetters[$u16] : typeSetters[$u32]\n                offset += maskSetter === typeSetters[$u8] ? 1 : maskSetter === typeSetters[$u16] ? 2 : 4\n                \n                let componentMask = 0\n                for (let j = 0; j < componentSerializers.length; j++) {\n                    const bytesWritten = componentSerializers[j](view, offset, entityId)\n                    if (bytesWritten > 0) {\n                        componentMask |= 1 << j\n                        offset += bytesWritten\n                    }\n                }\n                \n                // Write the component mask\n                maskSetter(view, maskOffset, componentMask)\n            } else {\n                // Write entity ID\n                offset += typeSetters[$u32](view, offset, entityId)\n                \n                // Write all components\n                for (let j = 0; j < componentSerializers.length; j++) {\n                    offset += componentSerializers[j](view, offset, entityId)\n                }\n            }\n        }\n        \n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Options for AoS deserializer\n */\nexport type AoSDeserializerOptions = {\n    diff?: boolean\n}\n\n/**\n * Creates a deserializer function for Array of Structures (AoS) components.\n * @param {AoSComponentRef[]} components - The AoS components to deserialize.\n * @param {AoSDeserializerOptions} [options] - Deserializer options.\n * @returns {Function} A function that deserializes the AoS data.\n */\nexport const createAoSDeserializer = (components: AnyAoSComponent[], options: AoSDeserializerOptions = {}) => {\n    const { diff = false } = options\n    const componentDeserializers = components.map(component => createAoSComponentDeserializer(component))\n\n    return (packet: ArrayBuffer, entityIdMapping?: Map<number, number>): void => {\n        const view = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            // Read entity ID\n            const { value: originalEntityId, size: entityIdSize } = typeGetters[$u32](view, offset)\n            offset += entityIdSize\n            const entityId = entityIdMapping ? entityIdMapping.get(originalEntityId) ?? originalEntityId : originalEntityId\n\n            if (diff) {\n                // Read component mask\n                const maskGetter = components.length <= 8 ? typeGetters[$u8] : components.length <= 16 ? typeGetters[$u16] : typeGetters[$u32]\n                const { value: componentMask, size: maskSize } = maskGetter(view, offset)\n                offset += maskSize\n\n                // Read changed components\n                for (let i = 0; i < components.length; i++) {\n                    if (componentMask & (1 << i)) {\n                        offset += componentDeserializers[i](view, offset, entityId, entityIdMapping)\n                    }\n                }\n            } else {\n                // Read all components\n                for (let i = 0; i < componentDeserializers.length; i++) {\n                    offset += componentDeserializers[i](view, offset, entityId, entityIdMapping)\n                }\n            }\n        }\n    }\n}", "import { createSoASerializer, createSoADeserializer, PrimitiveBrand } from './SoASerializer'\nimport {\n    addComponent,\n    hasComponent,\n    World,\n    getAllEntities,\n    addEntity,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    Relation,\n    ComponentRef,\n    query\n} from 'bitecs'\nimport { $u8, $i8, $u16, $i16, $u32, $i32, $f32, $ref } from './SoASerializer'\n\n/**\n * Serializes relation data for a specific entity\n */\nfunction serializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        const value = data[eid]\n        if (value !== undefined) {\n            if ($ref in data) {\n                dataView.setUint32(offset, value)\n                return offset + 4\n            } else {\n                dataView.setFloat64(offset, value)\n                return offset + 8\n            }\n        }\n        return offset\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            const value = arr[eid]\n            \n            if (value !== undefined) {\n                if (arr instanceof Int8Array || $i8 in arr) {\n                    dataView.setInt8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Uint8Array || $u8 in arr) {\n                    dataView.setUint8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Int16Array || $i16 in arr) {\n                    dataView.setInt16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Uint16Array || $u16 in arr) {\n                    dataView.setUint16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Int32Array || $i32 in arr) {\n                    dataView.setInt32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Uint32Array || $u32 in arr || $ref in arr) {\n                    dataView.setUint32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Float32Array || $f32 in arr) {\n                    dataView.setFloat32(offset, value)\n                    offset += 4\n                } else {\n                    // Default to f64\n                    dataView.setFloat64(offset, value)\n                    offset += 8\n                }\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Deserializes relation data for a specific entity\n */\nfunction deserializeRelationData(data: any, eid: number, dataView: DataView, offset: number, entityIdMapping?: Map<number, number>) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        if ($ref in data) {\n            const value = dataView.getUint32(offset)\n            const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n            data[eid] = mapped\n            return offset + 4\n        }\n        data[eid] = dataView.getFloat64(offset)\n        return offset + 8\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            \n            if (arr instanceof Int8Array || $i8 in arr) {\n                arr[eid] = dataView.getInt8(offset)\n                offset += 1\n            } else if (arr instanceof Uint8Array || $u8 in arr) {\n                arr[eid] = dataView.getUint8(offset)\n                offset += 1\n            } else if (arr instanceof Int16Array || $i16 in arr) {\n                arr[eid] = dataView.getInt16(offset)\n                offset += 2\n            } else if (arr instanceof Uint16Array || $u16 in arr) {\n                arr[eid] = dataView.getUint16(offset)\n                offset += 2\n            } else if (arr instanceof Int32Array || $i32 in arr) {\n                arr[eid] = dataView.getInt32(offset)\n                offset += 4\n            } else if (arr instanceof Uint32Array || $u32 in arr || $ref in arr) {\n                const value = dataView.getUint32(offset)\n                if ($ref in arr) {\n                    const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n                    arr[eid] = mapped\n                } else {\n                    arr[eid] = value\n                }\n                offset += 4\n            } else if (arr instanceof Float32Array || $f32 in arr) {\n                arr[eid] = dataView.getFloat32(offset)\n                offset += 4\n            } else {\n                // Default to f64\n                arr[eid] = dataView.getFloat64(offset)\n                offset += 8\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Creates a snapshot serializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @param {ArrayBuffer} [buffer=new ArrayBuffer(1024 * 1024 * 100)] - The buffer to use for serialization.\n * @returns {Function} A function that, when called, serializes the world state and returns a slice of the buffer.\n */\nexport const createSnapshotSerializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[], buffer: ArrayBuffer = new ArrayBuffer(1024 * 1024 * 100)) => {\n    const dataView = new DataView(buffer)\n    let offset = 0\n\n    /**\n     * Serializes entity-component relationships.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeEntityComponentRelationships = (entities: readonly number[]) => {\n        const entityCount = entities.length\n        \n        // Write entity count\n        dataView.setUint32(offset, entityCount)\n        offset += 4\n\n        // Serialize entity-component relationships\n        for (let i = 0; i < entityCount; i++) {\n            const entityId = entities[i]\n            let componentCount = 0\n            \n            dataView.setUint32(offset, entityId)\n            offset += 4\n            \n            const componentCountOffset = offset\n            offset += 1\n            \n            for (let j = 0; j < components.length; j++) {\n                const component = components[j]\n                if (isRelation(component)) {\n                    const targets = getRelationTargets(world, entityId, component as Relation<any>)\n                    for (const target of targets) {\n                        dataView.setUint8(offset, j)\n                        offset += 1\n                        dataView.setUint32(offset, target)\n                        offset += 4\n                        const relationData = (component as any)(target)\n                        offset = serializeRelationData(relationData, entityId, dataView, offset)\n                        componentCount++\n                    }\n                } else if (hasComponent(world, entityId, component)) {\n                    dataView.setUint8(offset, j)\n                    offset += 1\n                    componentCount++\n                }\n            }\n            \n            dataView.setUint8(componentCountOffset, componentCount)\n        }\n    }\n\n    /**\n     * Serializes component data for all entities.\n     * @param {number[]} entities - An array of entity IDs.\n     */\n    const serializeComponentData = (entities: readonly number[]) => {\n        const soaSerializer = createSoASerializer(components, { buffer: buffer.slice(offset) })\n        const componentData = soaSerializer(entities)\n        new Uint8Array(buffer).set(new Uint8Array(componentData), offset)\n        offset += componentData.byteLength\n    }\n\n    return (selectedEntities?: readonly number[]) => {\n        offset = 0\n        const entities = selectedEntities ?? getAllEntities(world)\n        serializeEntityComponentRelationships(entities)\n        serializeComponentData(entities)\n        return buffer.slice(0, offset)\n    }\n}\n\n/**\n * Creates a snapshot deserializer for the given world and components.\n * @param {World} world - The ECS world object.\n * @param {Record<string, PrimitiveBrand>[]} components - An array of component definitions.\n * @returns {Function} A function that takes a serialized packet and deserializes it into the world, returning a map of packet entity IDs to world entity IDs.\n */\nexport const createSnapshotDeserializer = (world: World, components: (Record<string, PrimitiveBrand> | ComponentRef)[], idMap?: Map<number, number>) => {\n    let entityIdMapping = idMap || new Map<number, number>()\n    const soaDeserializer = createSoADeserializer(components)\n\n    return (packet: ArrayBuffer, idMapOverride?: Map<number, number>): Map<number, number> => {\n        const currentMapping = idMapOverride || entityIdMapping\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        // Read entity count\n        const entityCount = dataView.getUint32(offset)\n        offset += 4\n\n        // Deserialize entity-component relationships\n        for (let entityIndex = 0; entityIndex < entityCount; entityIndex++) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n\n            let worldEntityId = currentMapping.get(packetEntityId)\n            if (worldEntityId === undefined) {\n                worldEntityId = addEntity(world)\n                currentMapping.set(packetEntityId, worldEntityId)\n            }\n\n            const componentCount = dataView.getUint8(offset)\n            offset += 1\n\n            for (let i = 0; i < componentCount; i++) {\n                const componentIndex = dataView.getUint8(offset)\n                offset += 1\n                const component = components[componentIndex]\n                \n                if (isRelation(component)) {\n                    const targetId = dataView.getUint32(offset)\n                    offset += 4\n                    let worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId === undefined) {\n                        worldTargetId = addEntity(world)\n                        currentMapping.set(targetId, worldTargetId)\n                    }\n                    const relationComponent = (component as (target: any) => any)(worldTargetId)\n                    addComponent(world, worldEntityId, relationComponent)\n                    offset = deserializeRelationData(relationComponent, worldEntityId, dataView, offset, currentMapping)\n                } else {\n                    addComponent(world, worldEntityId, component)\n                }\n            }\n        }\n\n        // Deserialize component data\n        soaDeserializer(packet.slice(offset), currentMapping)\n\n        return currentMapping\n    }\n}\n\n\nexport const test = (w:any) => {\n    return w === Wildcard\n}", "import {\n    addComponent,\n    removeComponent,\n    addEntity,\n    removeEntity,\n    observe,\n    onAdd,\n    onRemove,\n    World,\n    ComponentRef,\n    entityExists,\n    isRelation,\n    getRelationTargets,\n    Wildcard,\n    EntityId\n} from 'bitecs'\n\nenum OperationType {\n    AddEntity = 0,\n    RemoveEntity = 1,\n    AddComponent = 2,\n    RemoveComponent = 3,\n    AddRelation = 4,\n    RemoveRelation = 5,\n}\nimport { $u8, $i8, $u16, $i16, $u32, $i32, $f32, $ref } from './SoASerializer'\n\n/**\n * Serializes relation data for a specific entity\n */\nfunction serializeRelationData(data: any, eid: number, dataView: DataView, offset: number) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        const value = data[eid]\n        if (value !== undefined) {\n            if ($ref in data) {\n                dataView.setUint32(offset, value)\n                return offset + 4\n            } else {\n                dataView.setFloat64(offset, value)\n                return offset + 8\n            }\n        }\n        return offset\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            const value = arr[eid]\n            \n            if (value !== undefined) {\n                if (arr instanceof Int8Array || $i8 in arr) {\n                    dataView.setInt8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Uint8Array || $u8 in arr) {\n                    dataView.setUint8(offset, value)\n                    offset += 1\n                } else if (arr instanceof Int16Array || $i16 in arr) {\n                    dataView.setInt16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Uint16Array || $u16 in arr) {\n                    dataView.setUint16(offset, value)\n                    offset += 2\n                } else if (arr instanceof Int32Array || $i32 in arr) {\n                    dataView.setInt32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Uint32Array || $u32 in arr || $ref in arr) {\n                    dataView.setUint32(offset, value)\n                    offset += 4\n                } else if (arr instanceof Float32Array || $f32 in arr) {\n                    dataView.setFloat32(offset, value)\n                    offset += 4\n                } else {\n                    // Default to f64\n                    dataView.setFloat64(offset, value)\n                    offset += 8\n                }\n            }\n        }\n    }\n    \n    return offset\n}\n\n/**\n * Deserializes relation data for a specific entity\n */\nfunction deserializeRelationData(data: any, eid: number, dataView: DataView, offset: number, entityIdMapping?: Map<number, number>) {\n    if (!data) return offset\n    \n    // Handle array data (AoS) - defaults to f64\n    if (Array.isArray(data)) {\n        if ($ref in data) {\n            const value = dataView.getUint32(offset)\n            const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n            data[eid] = mapped\n            return offset + 4\n        }\n        data[eid] = dataView.getFloat64(offset)\n        return offset + 8\n    }\n    \n    // Handle object data (SoA)\n    if (typeof data === 'object') {\n        const keys = Object.keys(data).sort()\n        for (const key of keys) {\n            const arr = data[key]\n            \n            if (arr instanceof Int8Array || $i8 in arr) {\n                arr[eid] = dataView.getInt8(offset)\n                offset += 1\n            } else if (arr instanceof Uint8Array || $u8 in arr) {\n                arr[eid] = dataView.getUint8(offset)\n                offset += 1\n            } else if (arr instanceof Int16Array || $i16 in arr) {\n                arr[eid] = dataView.getInt16(offset)\n                offset += 2\n            } else if (arr instanceof Uint16Array || $u16 in arr) {\n                arr[eid] = dataView.getUint16(offset)\n                offset += 2\n            } else if (arr instanceof Int32Array || $i32 in arr) {\n                arr[eid] = dataView.getInt32(offset)\n                offset += 4\n            } else if (arr instanceof Uint32Array || $u32 in arr || $ref in arr) {\n                const value = dataView.getUint32(offset)\n                if ($ref in arr) {\n                    const mapped = entityIdMapping ? entityIdMapping.get(value) ?? value : value\n                    arr[eid] = mapped\n                } else {\n                    arr[eid] = value\n                }\n                offset += 4\n            } else if (arr instanceof Float32Array || $f32 in arr) {\n                arr[eid] = dataView.getFloat32(offset)\n                offset += 4\n            } else {\n                // Default to f64\n                arr[eid] = dataView.getFloat64(offset)\n                offset += 8\n            }\n        }\n    }\n    \n    return offset\n}\n\nexport type ObserverSerializerOptions = {\n    buffer?: ArrayBuffer\n}\n\n/**\n * Creates a serializer for observing and serializing changes in networked entities.\n */\nexport const createObserverSerializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], options: ObserverSerializerOptions = {}) => {\n    const backingBuffer = options.buffer ?? new ArrayBuffer(1024 * 1024 * 100)\n    const dataView = new DataView(backingBuffer)\n    let offset = 0\n    const queue: [number, OperationType, number, number?, any?][] = []\n    const relationTargets = new Map<number, Map<number, number>>()\n    \n    observe(world, onAdd(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.AddEntity, -1])\n    })\n\n    observe(world, onRemove(networkedTag), (eid: EntityId) => {\n        queue.push([eid, OperationType.RemoveEntity, -1])\n        relationTargets.delete(eid)\n    })\n\n    components.forEach((component, i) => {\n        if (isRelation(component)) {\n            observe(world, onAdd(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targets = getRelationTargets(world, eid, component)\n                for (const target of targets) {\n                    if (!relationTargets.has(eid)) {\n                        relationTargets.set(eid, new Map())\n                    }\n                    relationTargets.get(eid).set(i, target)\n                    const relationData = component(target)\n                    queue.push([eid, OperationType.AddRelation, i, target, relationData])\n                }\n            })\n\n            observe(world, onRemove(networkedTag, component(Wildcard)), (eid: EntityId) => {\n                const targetMap = relationTargets.get(eid)\n                if (targetMap) {\n                    const target = targetMap.get(i)\n                    if (target !== undefined) {\n                        queue.push([eid, OperationType.RemoveRelation, i, target])\n                        targetMap.delete(i)\n                        if (targetMap.size === 0) {\n                            relationTargets.delete(eid)\n                        }\n                    }\n                }\n            })\n        } else {\n            observe(world, onAdd(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.AddComponent, i])\n            })\n\n            observe(world, onRemove(networkedTag, component), (eid: EntityId) => {\n                queue.push([eid, OperationType.RemoveComponent, i])\n            })\n        }\n    })\n    \n    return () => {\n        offset = 0\n        \n        for (let i = 0; i < queue.length; i++) {\n            const [entityId, type, componentId, targetId, relationData] = queue[i]\n            dataView.setUint32(offset, entityId)\n            offset += 4\n            dataView.setUint8(offset, type)\n            offset += 1\n            if (type === OperationType.AddComponent || \n                type === OperationType.RemoveComponent || \n                type === OperationType.AddRelation ||\n                type === OperationType.RemoveRelation) {\n                dataView.setUint8(offset, componentId)\n                offset += 1\n                \n                if (type === OperationType.AddRelation || type === OperationType.RemoveRelation) {\n                    dataView.setUint32(offset, targetId)\n                    offset += 4\n                    \n                    if (type === OperationType.AddRelation && relationData) {\n                        offset = serializeRelationData(relationData, entityId, dataView, offset)\n                    }\n                }\n            }\n        }\n        queue.length = 0\n\n        return backingBuffer.slice(0, offset)\n    }\n}\n\nexport type ObserverDeserializerOptions = {\n    idMap?: Map<number, number>\n}\n\n/**\n * Creates a deserializer for applying serialized changes to a world.\n */\nexport const createObserverDeserializer = (world: World, networkedTag: ComponentRef, components: ComponentRef[], options: ObserverDeserializerOptions = {}) => {\n    let entityIdMapping = options.idMap || new Map<number, number>()\n    \n    return (packet: ArrayBuffer, idMap?: Map<number, number>) => {\n        // Allow overriding the mapping for this call\n        const currentMapping = idMap || entityIdMapping\n        const dataView = new DataView(packet)\n        let offset = 0\n\n        while (offset < packet.byteLength) {\n            const packetEntityId = dataView.getUint32(offset)\n            offset += 4\n            const operationType = dataView.getUint8(offset)\n            offset += 1\n            let componentId = -1\n            let targetId = -1\n            \n            if (operationType === OperationType.AddComponent || \n                operationType === OperationType.RemoveComponent ||\n                operationType === OperationType.AddRelation ||\n                operationType === OperationType.RemoveRelation) {\n                componentId = dataView.getUint8(offset)\n                offset += 1\n                \n                if (operationType === OperationType.AddRelation || operationType === OperationType.RemoveRelation) {\n                    targetId = dataView.getUint32(offset)\n                    offset += 4\n                }\n            }\n\n            const component = components[componentId]\n            let worldEntityId = currentMapping.get(packetEntityId)\n\n            if (operationType === OperationType.AddEntity) {\n                if (worldEntityId === undefined) {\n                    worldEntityId = addEntity(world)\n                    currentMapping.set(packetEntityId, worldEntityId)\n                    addComponent(world, worldEntityId, networkedTag)\n                } else {\n                    // TODO: figure out if this should ignore, throw, warn, or if the observer serializer should maybe do a snapshot on first call?\n                    // throw new Error(`Entity with ID ${packetEntityId} already exists in the mapping.`)\n                    console.warn(`Attempted to deserialize addEntity with ID ${packetEntityId}, but it has already been deserialzied and exists in the mapping.`)\n                }\n            } else if (worldEntityId !== undefined && entityExists(world, worldEntityId)) {\n                if (operationType === OperationType.RemoveEntity) {\n                    removeEntity(world, worldEntityId)\n                    currentMapping.delete(packetEntityId)\n                } else if (operationType === OperationType.AddComponent) {\n                    addComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.RemoveComponent) {\n                    removeComponent(world, worldEntityId, component)\n                } else if (operationType === OperationType.AddRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        const relationComponent = component(worldTargetId)\n                        addComponent(world, worldEntityId, relationComponent)\n                        offset = deserializeRelationData(relationComponent, worldEntityId, dataView, offset, currentMapping)\n                    }\n                } else if (operationType === OperationType.RemoveRelation) {\n                    const worldTargetId = currentMapping.get(targetId)\n                    if (worldTargetId !== undefined) {\n                        removeComponent(world, worldEntityId, component(worldTargetId))\n                    }\n                }\n            }\n        }\n\n        return currentMapping\n    }\n}\n"],
  "mappings": "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",
  "names": ["serialization_exports", "__export", "$f32", "$f64", "$i16", "$i32", "$i8", "$ref", "$str", "$u16", "$u32", "$u8", "array", "createAoSDeserializer", "createAoSSerializer", "createObserverDeserializer", "createObserverSerializer", "createSnapshotDeserializer", "createSnapshotSerializer", "createSoADeserializer", "createSoASerializer", "f32", "f64", "i16", "i32", "i8", "ref", "str", "u16", "u32", "u8", "__toCommonJS", "$u8", "$i8", "$u16", "$i16", "$u32", "$i32", "$f32", "$f64", "$ref", "$str", "$arr", "typeTagForSerialization", "symbol", "a", "u8", "i8", "u16", "i16", "u32", "i32", "f32", "f64", "ref", "str", "functionToSymbolMap", "typeSetters", "view", "offset", "value", "bytes", "textEncoder", "written", "typeGetters", "len", "lenSize", "textDecoder", "resolveTypeToSymbol", "type", "isArrayType", "array", "arr", "isTypedArrayOrBranded", "getTypeForArray", "getArrayElementType", "arrayType", "serializeArrayValue", "elementType", "bytesWritten", "isArrayDefined", "i", "element", "deserializeArrayValue", "entityIdMapping", "bytesRead", "isArrayResult", "arrayLengthResult", "size", "mapped", "isFloatType", "getEpsilonForType", "epsilon", "getShadow", "shadowMap", "shadow", "hasChanged", "index", "currentValue", "actualEpsilon", "changed", "createComponentSerializer", "component", "diff", "setter", "componentId", "props", "setters", "prop", "changeMask", "componentProperty", "maskSetter", "createComponentDeserializer", "getter", "originalIndex", "indexSize", "cidSize", "types", "getters", "maskGetter", "maskSize", "createSoASerializer", "components", "options", "buffer", "componentSerializers", "indices", "j", "createSoADeserializer", "componentDeserializers", "packet", "originalEid", "eidSize", "isFloatType", "array", "arrayType", "getTypeForArray", "$f32", "$f64", "getEpsilonForType", "epsilon", "getShadowComponent", "shadowMap", "component", "shadow", "hasComponentChanged", "entityId", "currentValue", "shadowValue", "componentDef", "prop", "propEpsilon", "valueEpsilon", "updateShadow", "createAoSComponentSerializer", "diff", "key", "props", "setters", "type", "typeSetters", "view", "offset", "value", "bytesWritten", "i", "propValue", "isArrayType", "serializeArrayValue", "getArrayElementType", "setter", "createAoSComponentDeserializer", "types", "getters", "typeGetters", "entityIdMapping", "bytesRead", "size", "deserializeArrayValue", "$ref", "mapped", "getter", "createAoSSerializer", "components", "options", "buffer", "componentSerializers", "entityIds", "entityHasChanges", "j", "$u32", "maskOffset", "maskSetter", "$u8", "$u16", "componentMask", "createAoSDeserializer", "componentDeserializers", "packet", "originalEntityId", "entityIdSize", "maskGetter", "maskSize", "import_bitecs", "serializeRelationData", "data", "eid", "dataView", "offset", "value", "$ref", "keys", "key", "arr", "$i8", "$u8", "$i16", "$u16", "$i32", "$u32", "$f32", "deserializeRelationData", "entityIdMapping", "mapped", "createSnapshotSerializer", "world", "components", "buffer", "serializeEntityComponentRelationships", "entities", "entityCount", "i", "entityId", "componentCount", "componentCountOffset", "j", "component", "targets", "target", "relationData", "serializeComponentData", "componentData", "createSoASerializer", "selectedEntities", "createSnapshotDeserializer", "idMap", "soaDeserializer", "createSoADeserializer", "packet", "idMapOverride", "currentMapping", "entityIndex", "packetEntityId", "worldEntityId", "componentIndex", "targetId", "worldTargetId", "relationComponent", "import_bitecs", "serializeRelationData", "data", "eid", "dataView", "offset", "value", "$ref", "keys", "key", "arr", "$i8", "$u8", "$i16", "$u16", "$i32", "$u32", "$f32", "deserializeRelationData", "entityIdMapping", "mapped", "createObserverSerializer", "world", "networkedTag", "components", "options", "backingBuffer", "queue", "relationTargets", "component", "i", "targets", "target", "relationData", "targetMap", "entityId", "type", "componentId", "targetId", "createObserverDeserializer", "packet", "idMap", "currentMapping", "packetEntityId", "operationType", "worldEntityId", "worldTargetId", "relationComponent"]
}
